{"ast":null,"code":"(function (f) {\n  if (typeof exports === \"object\" && typeof module !== \"undefined\") {\n    module.exports = f();\n  } else if (typeof define === \"function\" && define.amd) {\n    define([], f);\n  } else {\n    var g;\n\n    if (typeof window !== \"undefined\") {\n      g = window;\n    } else if (typeof global !== \"undefined\") {\n      g = global;\n    } else if (typeof self !== \"undefined\") {\n      g = self;\n    } else {\n      g = this;\n    }\n\n    g.cssFontFaceSrc = f();\n  }\n})(function () {\n  var define, module, exports;\n  return function e(t, n, r) {\n    function s(o, u) {\n      if (!n[o]) {\n        if (!t[o]) {\n          var a = typeof require == \"function\" && require;\n          if (!u && a) return a(o, !0);\n          if (i) return i(o, !0);\n          var f = new Error(\"Cannot find module '\" + o + \"'\");\n          throw f.code = \"MODULE_NOT_FOUND\", f;\n        }\n\n        var l = n[o] = {\n          exports: {}\n        };\n        t[o][0].call(l.exports, function (e) {\n          var n = t[o][1][e];\n          return s(n ? n : e);\n        }, l, l.exports, e, t, n, r);\n      }\n\n      return n[o].exports;\n    }\n\n    var i = typeof require == \"function\" && require;\n\n    for (var o = 0; o < r.length; o++) s(r[o]);\n\n    return s;\n  }({\n    1: [function (_dereq_, module, exports) {\n      /*\n       * Generated by PEG.js 0.10.0.\n       *\n       * http://pegjs.org/\n       */\n      \"use strict\";\n\n      function peg$subclass(child, parent) {\n        function ctor() {\n          this.constructor = child;\n        }\n\n        ctor.prototype = parent.prototype;\n        child.prototype = new ctor();\n      }\n\n      function peg$SyntaxError(message, expected, found, location) {\n        this.message = message;\n        this.expected = expected;\n        this.found = found;\n        this.location = location;\n        this.name = \"SyntaxError\";\n\n        if (typeof Error.captureStackTrace === \"function\") {\n          Error.captureStackTrace(this, peg$SyntaxError);\n        }\n      }\n\n      peg$subclass(peg$SyntaxError, Error);\n\n      peg$SyntaxError.buildMessage = function (expected, found) {\n        var DESCRIBE_EXPECTATION_FNS = {\n          literal: function (expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n          \"class\": function (expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1]) : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n          any: function (expectation) {\n            return \"any character\";\n          },\n          end: function (expectation) {\n            return \"end of input\";\n          },\n          other: function (expectation) {\n            return expectation.description;\n          }\n        };\n\n        function hex(ch) {\n          return ch.charCodeAt(0).toString(16).toUpperCase();\n        }\n\n        function literalEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function classEscape(s) {\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\\]/g, '\\\\]').replace(/\\^/g, '\\\\^').replace(/-/g, '\\\\-').replace(/\\0/g, '\\\\0').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          });\n        }\n\n        function describeExpectation(expectation) {\n          return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n        }\n\n        function describeExpected(expected) {\n          var descriptions = new Array(expected.length),\n              i,\n              j;\n\n          for (i = 0; i < expected.length; i++) {\n            descriptions[i] = describeExpectation(expected[i]);\n          }\n\n          descriptions.sort();\n\n          if (descriptions.length > 0) {\n            for (i = 1, j = 1; i < descriptions.length; i++) {\n              if (descriptions[i - 1] !== descriptions[i]) {\n                descriptions[j] = descriptions[i];\n                j++;\n              }\n            }\n\n            descriptions.length = j;\n          }\n\n          switch (descriptions.length) {\n            case 1:\n              return descriptions[0];\n\n            case 2:\n              return descriptions[0] + \" or \" + descriptions[1];\n\n            default:\n              return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n          }\n        }\n\n        function describeFound(found) {\n          return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n        }\n\n        return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n      };\n\n      function peg$parse(input, options) {\n        options = options !== void 0 ? options : {};\n\n        var peg$FAILED = {},\n            peg$startRuleFunctions = {\n          start: peg$parsestart\n        },\n            peg$startRuleFunction = peg$parsestart,\n            peg$c0 = \"\",\n            peg$c1 = function () {\n          return [];\n        },\n            peg$c2 = \",\",\n            peg$c3 = peg$literalExpectation(\",\", false),\n            peg$c4 = function (x, xs) {\n          return [x].concat(xs);\n        },\n            peg$c5 = function (entry) {\n          return [entry];\n        },\n            peg$c6 = function (url, format) {\n          return {\n            url: url,\n            format: format\n          };\n        },\n            peg$c7 = function (url) {\n          return {\n            url: url\n          };\n        },\n            peg$c8 = \"url(\",\n            peg$c9 = peg$literalExpectation(\"url(\", false),\n            peg$c10 = \")\",\n            peg$c11 = peg$literalExpectation(\")\", false),\n            peg$c12 = function (value) {\n          return value;\n        },\n            peg$c13 = \"format(\",\n            peg$c14 = peg$literalExpectation(\"format(\", false),\n            peg$c15 = \"local(\",\n            peg$c16 = peg$literalExpectation(\"local(\", false),\n            peg$c17 = function (value) {\n          return {\n            local: value\n          };\n        },\n            peg$c18 = /^[^)]/,\n            peg$c19 = peg$classExpectation([\")\"], true, false),\n            peg$c20 = function (chars) {\n          return util.extractValue(chars.join(\"\"));\n        },\n            peg$c21 = /^[ \\t\\r\\n\\f]/,\n            peg$c22 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\", \"\\f\"], false, false),\n            peg$currPos = 0,\n            peg$savedPos = 0,\n            peg$posDetailsCache = [{\n          line: 1,\n          column: 1\n        }],\n            peg$maxFailPos = 0,\n            peg$maxFailExpected = [],\n            peg$silentFails = 0,\n            peg$result;\n\n        if (\"startRule\" in options) {\n          if (!(options.startRule in peg$startRuleFunctions)) {\n            throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n          }\n\n          peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n        }\n\n        function text() {\n          return input.substring(peg$savedPos, peg$currPos);\n        }\n\n        function location() {\n          return peg$computeLocation(peg$savedPos, peg$currPos);\n        }\n\n        function expected(description, location) {\n          location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n          throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n        }\n\n        function error(message, location) {\n          location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n          throw peg$buildSimpleError(message, location);\n        }\n\n        function peg$literalExpectation(text, ignoreCase) {\n          return {\n            type: \"literal\",\n            text: text,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$classExpectation(parts, inverted, ignoreCase) {\n          return {\n            type: \"class\",\n            parts: parts,\n            inverted: inverted,\n            ignoreCase: ignoreCase\n          };\n        }\n\n        function peg$anyExpectation() {\n          return {\n            type: \"any\"\n          };\n        }\n\n        function peg$endExpectation() {\n          return {\n            type: \"end\"\n          };\n        }\n\n        function peg$otherExpectation(description) {\n          return {\n            type: \"other\",\n            description: description\n          };\n        }\n\n        function peg$computePosDetails(pos) {\n          var details = peg$posDetailsCache[pos],\n              p;\n\n          if (details) {\n            return details;\n          } else {\n            p = pos - 1;\n\n            while (!peg$posDetailsCache[p]) {\n              p--;\n            }\n\n            details = peg$posDetailsCache[p];\n            details = {\n              line: details.line,\n              column: details.column\n            };\n\n            while (p < pos) {\n              if (input.charCodeAt(p) === 10) {\n                details.line++;\n                details.column = 1;\n              } else {\n                details.column++;\n              }\n\n              p++;\n            }\n\n            peg$posDetailsCache[pos] = details;\n            return details;\n          }\n        }\n\n        function peg$computeLocation(startPos, endPos) {\n          var startPosDetails = peg$computePosDetails(startPos),\n              endPosDetails = peg$computePosDetails(endPos);\n          return {\n            start: {\n              offset: startPos,\n              line: startPosDetails.line,\n              column: startPosDetails.column\n            },\n            end: {\n              offset: endPos,\n              line: endPosDetails.line,\n              column: endPosDetails.column\n            }\n          };\n        }\n\n        function peg$fail(expected) {\n          if (peg$currPos < peg$maxFailPos) {\n            return;\n          }\n\n          if (peg$currPos > peg$maxFailPos) {\n            peg$maxFailPos = peg$currPos;\n            peg$maxFailExpected = [];\n          }\n\n          peg$maxFailExpected.push(expected);\n        }\n\n        function peg$buildSimpleError(message, location) {\n          return new peg$SyntaxError(message, null, null, location);\n        }\n\n        function peg$buildStructuredError(expected, found, location) {\n          return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n        }\n\n        function peg$parsestart() {\n          var s0, s1;\n          s0 = peg$parsesourceEntries();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$c0;\n\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c1();\n            }\n\n            s0 = s1;\n          }\n\n          return s0;\n        }\n\n        function peg$parsesourceEntries() {\n          var s0, s1, s2, s3, s4, s5;\n          s0 = peg$currPos;\n          s1 = peg$parsesourceEntry();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewhitespace();\n\n            while (s3 !== peg$FAILED) {\n              s2.push(s3);\n              s3 = peg$parsewhitespace();\n            }\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 44) {\n                s3 = peg$c2;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c3);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                s4 = [];\n                s5 = peg$parsewhitespace();\n\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = peg$parsewhitespace();\n                }\n\n                if (s4 !== peg$FAILED) {\n                  s5 = peg$parsesourceEntries();\n\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c4(s1, s5);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parsesourceEntry();\n\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c5(s1);\n            }\n\n            s0 = s1;\n          }\n\n          return s0;\n        }\n\n        function peg$parsesourceEntry() {\n          var s0;\n          s0 = peg$parseurlEntry();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parselocalEntry();\n          }\n\n          return s0;\n        }\n\n        function peg$parseurlEntry() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n          s1 = peg$parseurl();\n\n          if (s1 !== peg$FAILED) {\n            s2 = [];\n            s3 = peg$parsewhitespace();\n\n            if (s3 !== peg$FAILED) {\n              while (s3 !== peg$FAILED) {\n                s2.push(s3);\n                s3 = peg$parsewhitespace();\n              }\n            } else {\n              s2 = peg$FAILED;\n            }\n\n            if (s2 !== peg$FAILED) {\n              s3 = peg$parseformat();\n\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c6(s1, s3);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            s1 = peg$parseurl();\n\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c7(s1);\n            }\n\n            s0 = s1;\n          }\n\n          return s0;\n        }\n\n        function peg$parseurl() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 4) === peg$c8) {\n            s1 = peg$c8;\n            peg$currPos += 4;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c9);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsevalue();\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s3 = peg$c10;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c12(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          return s0;\n        }\n\n        function peg$parseformat() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 7) === peg$c13) {\n            s1 = peg$c13;\n            peg$currPos += 7;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c14);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsevalue();\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s3 = peg$c10;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c12(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          return s0;\n        }\n\n        function peg$parselocalEntry() {\n          var s0, s1, s2, s3;\n          s0 = peg$currPos;\n\n          if (input.substr(peg$currPos, 6) === peg$c15) {\n            s1 = peg$c15;\n            peg$currPos += 6;\n          } else {\n            s1 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c16);\n            }\n          }\n\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parsevalue();\n\n            if (s2 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 41) {\n                s3 = peg$c10;\n                peg$currPos++;\n              } else {\n                s3 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c11);\n                }\n              }\n\n              if (s3 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c17(s2);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n\n          return s0;\n        }\n\n        function peg$parsevalue() {\n          var s0, s1, s2;\n          s0 = peg$currPos;\n          s1 = [];\n\n          if (peg$c18.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c19);\n            }\n          }\n\n          if (s2 !== peg$FAILED) {\n            while (s2 !== peg$FAILED) {\n              s1.push(s2);\n\n              if (peg$c18.test(input.charAt(peg$currPos))) {\n                s2 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s2 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c19);\n                }\n              }\n            }\n          } else {\n            s1 = peg$FAILED;\n          }\n\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c20(s1);\n          }\n\n          s0 = s1;\n          return s0;\n        }\n\n        function peg$parsewhitespace() {\n          var s0;\n\n          if (peg$c21.test(input.charAt(peg$currPos))) {\n            s0 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c22);\n            }\n          }\n\n          return s0;\n        }\n\n        var util = _dereq_('../util');\n\n        peg$result = peg$startRuleFunction();\n\n        if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n          return peg$result;\n        } else {\n          if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n            peg$fail(peg$endExpectation());\n          }\n\n          throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n        }\n      }\n\n      module.exports = {\n        SyntaxError: peg$SyntaxError,\n        parse: peg$parse\n      };\n    }, {\n      \"../util\": 3\n    }],\n    2: [function (_dereq_, module, exports) {\n      var grammar = _dereq_('./grammar');\n\n      exports.SyntaxError = function (message, offset) {\n        this.message = message;\n        this.offset = offset;\n      };\n\n      exports.parse = function (fontFaceSourceValue) {\n        try {\n          return grammar.parse(fontFaceSourceValue);\n        } catch (e) {\n          throw new exports.SyntaxError(e.message, e.offset);\n        }\n      };\n\n      exports.serialize = function (parsedFontFaceSources) {\n        return parsedFontFaceSources.map(function (sourceItem) {\n          var itemValue;\n\n          if (sourceItem.url) {\n            itemValue = 'url(\"' + sourceItem.url + '\")';\n\n            if (sourceItem.format) {\n              itemValue += ' format(\"' + sourceItem.format + '\")';\n            }\n          } else {\n            itemValue = 'local(\"' + sourceItem.local + '\")';\n          }\n\n          return itemValue;\n        }).join(', ');\n      };\n    }, {\n      \"./grammar\": 1\n    }],\n    3: [function (_dereq_, module, exports) {\n      var trimCSSWhitespace = function (value) {\n        var whitespaceRegex = /^[\\t\\r\\f\\n ]*(.+?)[\\t\\r\\f\\n ]*$/;\n        return value.replace(whitespaceRegex, \"$1\");\n      };\n\n      var unquoteString = function (quotedUrl) {\n        var doubleQuoteRegex = /^\"(.*)\"$/,\n            singleQuoteRegex = /^'(.*)'$/;\n\n        if (doubleQuoteRegex.test(quotedUrl)) {\n          return quotedUrl.replace(doubleQuoteRegex, \"$1\");\n        } else {\n          if (singleQuoteRegex.test(quotedUrl)) {\n            return quotedUrl.replace(singleQuoteRegex, \"$1\");\n          } else {\n            return quotedUrl;\n          }\n        }\n      };\n\n      exports.extractValue = function (value) {\n        return unquoteString(trimCSSWhitespace(value));\n      };\n    }, {}]\n  }, {}, [2])(2);\n});","map":{"version":3,"sources":["D:/act-back original/timetable_frontend/node_modules/css-font-face-src/dist/css-font-face-src.js"],"names":["f","exports","module","define","amd","g","window","global","self","cssFontFaceSrc","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","_dereq_","peg$subclass","child","parent","ctor","constructor","prototype","peg$SyntaxError","message","expected","found","location","name","captureStackTrace","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","escapedParts","parts","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","replace","describeExpectation","type","describeExpected","descriptions","j","sort","slice","join","describeFound","peg$parse","input","options","peg$FAILED","peg$startRuleFunctions","start","peg$parsestart","peg$startRuleFunction","peg$c0","peg$c1","peg$c2","peg$c3","peg$literalExpectation","peg$c4","x","xs","concat","peg$c5","entry","peg$c6","url","format","peg$c7","peg$c8","peg$c9","peg$c10","peg$c11","peg$c12","value","peg$c13","peg$c14","peg$c15","peg$c16","peg$c17","local","peg$c18","peg$c19","peg$classExpectation","peg$c20","chars","util","extractValue","peg$c21","peg$c22","peg$currPos","peg$savedPos","peg$posDetailsCache","line","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","peg$result","startRule","substring","peg$computeLocation","peg$buildStructuredError","peg$otherExpectation","error","peg$buildSimpleError","ignoreCase","peg$anyExpectation","peg$endExpectation","peg$computePosDetails","pos","details","p","startPos","endPos","startPosDetails","endPosDetails","offset","peg$fail","push","s0","s1","peg$parsesourceEntries","s2","s3","s4","s5","peg$parsesourceEntry","peg$parsewhitespace","peg$parseurlEntry","peg$parselocalEntry","peg$parseurl","peg$parseformat","substr","peg$parsevalue","test","charAt","SyntaxError","parse","grammar","fontFaceSourceValue","serialize","parsedFontFaceSources","map","sourceItem","itemValue","trimCSSWhitespace","whitespaceRegex","unquoteString","quotedUrl","doubleQuoteRegex","singleQuoteRegex"],"mappings":"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","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.cssFontFaceSrc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { start: peg$parsestart },\n      peg$startRuleFunction  = peg$parsestart,\n\n      peg$c0 = \"\",\n      peg$c1 = function() { return [] },\n      peg$c2 = \",\",\n      peg$c3 = peg$literalExpectation(\",\", false),\n      peg$c4 = function(x, xs) { return [x].concat(xs); },\n      peg$c5 = function(entry) { return [entry]; },\n      peg$c6 = function(url, format) { return {url: url, format: format}; },\n      peg$c7 = function(url) { return {url: url}; },\n      peg$c8 = \"url(\",\n      peg$c9 = peg$literalExpectation(\"url(\", false),\n      peg$c10 = \")\",\n      peg$c11 = peg$literalExpectation(\")\", false),\n      peg$c12 = function(value) { return value; },\n      peg$c13 = \"format(\",\n      peg$c14 = peg$literalExpectation(\"format(\", false),\n      peg$c15 = \"local(\",\n      peg$c16 = peg$literalExpectation(\"local(\", false),\n      peg$c17 = function(value) { return {local: value}; },\n      peg$c18 = /^[^)]/,\n      peg$c19 = peg$classExpectation([\")\"], true, false),\n      peg$c20 = function(chars) { return util.extractValue(chars.join(\"\")); },\n      peg$c21 = /^[ \\t\\r\\n\\f]/,\n      peg$c22 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\", \"\\f\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsestart() {\n    var s0, s1;\n\n    s0 = peg$parsesourceEntries();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$c0;\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesourceEntries() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesourceEntry();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewhitespace();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewhitespace();\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 44) {\n          s3 = peg$c2;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c3); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parsewhitespace();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parsewhitespace();\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsesourceEntries();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c4(s1, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsesourceEntry();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c5(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesourceEntry() {\n    var s0;\n\n    s0 = peg$parseurlEntry();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselocalEntry();\n    }\n\n    return s0;\n  }\n\n  function peg$parseurlEntry() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseurl();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewhitespace();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewhitespace();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseformat();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c6(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseurl();\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c7(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseurl() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 4) === peg$c8) {\n      s1 = peg$c8;\n      peg$currPos += 4;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s3 = peg$c10;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseformat() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 7) === peg$c13) {\n      s1 = peg$c13;\n      peg$currPos += 7;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c14); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s3 = peg$c10;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c12(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselocalEntry() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 6) === peg$c15) {\n      s1 = peg$c15;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c16); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsevalue();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s3 = peg$c10;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c11); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c17(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevalue() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c18.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c19); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c18.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c20(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewhitespace() {\n    var s0;\n\n    if (peg$c21.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c22); }\n    }\n\n    return s0;\n  }\n\n\n    var util = _dereq_('../util');\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n},{\"../util\":3}],2:[function(_dereq_,module,exports){\nvar grammar = _dereq_('./grammar');\n\n\nexports.SyntaxError = function (message, offset) {\n    this.message  = message;\n    this.offset   = offset;\n};\n\nexports.parse = function (fontFaceSourceValue) {\n    try {\n        return grammar.parse(fontFaceSourceValue);\n    } catch (e) {\n        throw new exports.SyntaxError(e.message, e.offset);\n    }\n};\n\nexports.serialize = function (parsedFontFaceSources) {\n    return parsedFontFaceSources.map(function (sourceItem) {\n        var itemValue;\n\n        if (sourceItem.url) {\n            itemValue = 'url(\"' + sourceItem.url + '\")';\n            if (sourceItem.format) {\n                itemValue += ' format(\"' + sourceItem.format + '\")';\n            }\n        } else {\n            itemValue = 'local(\"' + sourceItem.local + '\")';\n        }\n        return itemValue;\n    }).join(', ');\n};\n\n},{\"./grammar\":1}],3:[function(_dereq_,module,exports){\nvar trimCSSWhitespace = function (value) {\n    var whitespaceRegex = /^[\\t\\r\\f\\n ]*(.+?)[\\t\\r\\f\\n ]*$/;\n\n    return value.replace(whitespaceRegex, \"$1\");\n};\n\nvar unquoteString = function (quotedUrl) {\n    var doubleQuoteRegex = /^\"(.*)\"$/,\n        singleQuoteRegex = /^'(.*)'$/;\n\n    if (doubleQuoteRegex.test(quotedUrl)) {\n        return quotedUrl.replace(doubleQuoteRegex, \"$1\");\n    } else {\n        if (singleQuoteRegex.test(quotedUrl)) {\n            return quotedUrl.replace(singleQuoteRegex, \"$1\");\n        } else {\n            return quotedUrl;\n        }\n    }\n};\n\nexports.extractValue = function (value) {\n    return unquoteString(trimCSSWhitespace(value));\n};\n\n},{}]},{},[2])(2)\n});"]},"metadata":{},"sourceType":"script"}